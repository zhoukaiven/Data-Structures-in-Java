By Kaiven Zhou (kz2182)

An expression tree, which takes input from args[0], parses the input, 
and builds a tree by pushing and popping the data on/off a stack.

The expression tree has methods to print the prefix, infix, and postfix traversal of the tree,
as well as a method to evaluate the result of the original tree.

The result is calculated using integer operations (i.e. integer division occurs if division is in the input).

The output follows the notation outlined on page 109 of the textbook, 
namely, given postfix input "a b c * + d e * f + g * +" returns:
prefix:  + + a * b c * + * d e f g
infix: (a + (b*c)) + (((d*e) + f)*g)
postfix:  a b c * + d e * f + g * +

The Stack ADT implementation uses an ArrayList, and an int to keep track of the top of the list.
The integer, called "top", refers to where the next element added will go.
The pop method temporarily stores the element underneath "top", remove that element, and returns it. Then decrements "top".
The push method adds the new value at "top", then increments "top".

The prefix notation is generated by traversing the expression tree in preorder
by printing the prefix of the left subtree, then the prefix of the right subtree, then the parent's value.

The infix notation is generated by traversing the expression tree in order, by doing the following: 
- print a left bracket if the parent's value is an operator
- if the left subtree exists, print the infix of the left subtree
- print the parent's value
- if the right subtree exists, print the infix of the right subtree
- print a right bracket if the parent's value is an operator
The if statements on the brackets is prevents brackets from appearing solely around integers [ex. (4), doesnt happen]

The postfix notation is generated by traversing the expression tree in postorder 
by printing the parent's value, then the prefix of the left subtree, then the prefix of the right subtree.

The result is evaluated by calculating the results of the the left and right subtrees, then applying the parent's operator.